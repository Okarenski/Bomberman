/**
    Estrutura inicial para um jogo
    versão: 0.1 (Prof. Alex,  Adaptado Prof. Felski)
*/
#include <iostream>
#include <windows.h>
#include <conio.h>
#include <vector>
#include <chrono>
#include <mmsystem.h>

using namespace std;
using namespace std::chrono;

struct player
{
    int x,y;
};

struct inimigo
{
    int xi,yi;
};
struct PowerUPS
{
    int ExtraVida;
};
bool colisao(int p)  ///COLISAO
{
    return p == 0;
}
bool colisaInimigo(int G){ ///COLISAO DO INIMIGO
    return G !=0;
}

struct ExplosaoBomba
{
    int xboom, yboom;
};

void GeracaoInimigo(int m[13][27], int dificuldade, vector<pair<int,int>> &Inimigos) {
    srand(time(0));
    for (int i = 0; i < dificuldade; i++) {
        while (true) {
            int PosicaoAleatoriaY = rand() % 13;
            int PosicaoAleatoriaX = rand() % 27;
            if (m[PosicaoAleatoriaY][PosicaoAleatoriaX] == 0) {
                Inimigos.push_back({PosicaoAleatoriaY, PosicaoAleatoriaX});
                break;
            }
        }
    }
}
void MovimentoInimigo(vector<inimigo> &Inimigos, player &J, int dificuldade, int m[13][27]){
    int ProbabilidadeMoverParaPlayer = 0;
    if(dificuldade==5){
        ProbabilidadeMoverParaPlayer=50;
    } else if(dificuldade==7){
        ProbabilidadeMoverParaPlayer=75;
    }
        for(auto &inimigo:Inimigos){
            int MoverParaPlayer = rand()%100;
            if(MoverParaPlayer<ProbabilidadeMoverParaPlayer){
                if(inimigo.xi<J.x){
                    if(!colisaInimigo(m[inimigo.xi+1][inimigo.yi])){
                        inimigo.xi++;
                    }
                } else if(inimigo.xi>J.x){
                    if(!colisaInimigo(m[inimigo.xi-1][inimigo.yi])){
                        inimigo.xi--;
                    }
                }
                if(inimigo.yi<J.y){
                    if(!colisaInimigo(m[inimigo.xi][inimigo.yi+1])){
                        inimigo.yi++;
                    }
                } else if(inimigo.yi>J.y){
                    if(!colisaInimigo(m[inimigo.xi][inimigo.yi-1])){
                        inimigo.yi--;
                    }
                }
            } else {
                int Direcao = rand()%4;
                switch(Direcao){
            case 0: ///CIMA
                if(!colisaInimigo(m[inimigo.xi - 1][inimigo.yi])){
                    inimigo.xi--;
                }
                break;
            case 1: ///BAIXO
                if (!colisaInimigo(m[inimigo.xi + 1][inimigo.yi])) {
                    inimigo.xi++;
                }
                break;
            case 2: ///ESQUERDA
                if (!colisaInimigo(m[inimigo.xi][inimigo.yi - 1])) {
                    inimigo.yi--;
                }
                break;
            case 3: ///BAIXO
                if (!colisaInimigo(m[inimigo.xi][inimigo.yi + 1])) {
                    inimigo.yi++;
                }
                break;
                }
            }
        }
    }
void MapaIniciar(int m[13][27]) {
    srand(time(0));
    for (int i = 0; i < 13; i++) {
        for (int j = 0; j < 27; j++) {
            if (i == 0 || i == 12 || j == 0 || j == 26) {
                m[i][j] = 1;
            } else if ((i % 2 == 0) && (j % 2 == 0)) {
                m[i][j] = 1;
            } else {
                m[i][j] = 0;
            }
        }
    }
    for (int i = 1; i < 12; i++) {
        for (int j = 1; j < 26; j++) {
            if (m[i][j] == 0 && (rand() % 5 == 0)) {
                m[i][j] = 2; // Parede quebrável
            }
        }
    }
    m[1][1] = 0;
    m[1][2] = 0;
    m[5][5] = 0;
}
int main()
{


    using namespace chrono;
    milliseconds TempoAnimacao(500);
    milliseconds TempoInimigo (500);
    milliseconds BombaTimer   (3000);
    auto InicioBomba = chrono::high_resolution_clock::now();
    auto Inicio = chrono::high_resolution_clock::now();

    ///ALERTA: NAO MODIFICAR O TRECHO DE CODIGO, A SEGUIR.
    //INICIO: COMANDOS PARA QUE O CURSOR NAO FIQUE PISCANDO NA TELA
    HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO     cursorInfo;
    GetConsoleCursorInfo(out, &cursorInfo);
    cursorInfo.bVisible = false; // set the cursor visibility
    SetConsoleCursorInfo(out, &cursorInfo);
    //FIM: COMANDOS PARA QUE O CURSOR NAO FIQUE PISCANDO NA TELA

    //INICIO: COMANDOS PARA REPOSICIONAR O CURSOR NO INICIO DA TELA
    short int CX=0, CY=0;
    COORD coord;
    coord.X = CX;
    coord.Y = CY;
    //FIM: COMANDOS PARA REPOSICIONAR O CURSOR NO INICIO DA TELA
    ///ALERTA: NAO MODIFICAR O TRECHO DE CODIGO, ACIMA.

    bool GameContinue = true;

    int m[13][27];
    MapaIniciar(m);
    ///Bomba
    int XB=-3;
    int YB=-3;
    ///inimigo
    char enemy  (041);
    vector <inimigo> Inimigos;
    vector<pair<int,int>> InimigoPosicoes;

    ///Posicao inicial do personagem no console
    vector <player> J;
    J.push_back({5,5}); ///player 1
    ///J.push_back({5,4}); ///player 2

    int JogadoresVivos = J.size();
    ///Variavel para tecla precionada
    char tecla;
    ///Parade Quebravel
    char ParedeQuebravel (176);
    ///Bomba
    char Bomba           (022);
    char quente          (105);
    char kbom            (161);
    ///Vector da bomba
    vector <ExplosaoBomba> Explosoes;


    int menu = 0;
    do
    {
        PlaySound(TEXT("menu.wav"), NULL, SND_ASYNC);


        system ("cls");
        cout << " _______  _______  __   __  _______  _______  ______    __   __  _______  __    _ \n"
             "|  _    ||       ||  |_|  ||  _    ||       ||    _ |  |  |_|  ||   _   ||  |  | |\n"
             "| |_|   ||   _   ||       || |_|   ||    ___||   | ||  |       ||  |_|  ||   |_| |\n"
             "|       ||  | |  ||       ||       ||   |___ |   |_||_ |       ||       ||       |\n"
             "|  _   | |  |_|  ||       ||  _   | |    ___||    __  ||       ||       ||  _    |\n"
             "| |_|   ||       || ||_|| || |_|   ||   |___ |   |  | || ||_|| ||   _   || | |   |\n"
             "|_______||_______||_|   |_||_______||_______||___|  |_||_|   |_||__| |__||_|  |__|\n";


        cout <<"                          ______________________________ " << endl;
        cout << "                         | 1 - COMECAR                  |" << endl;
        cout << "                         | 2 - TUTORIAL                 |" << endl;
        cout << "                         | 3 - PONTUACAO                |" << endl;
        cout << "                         | 4 - RANKING                  |" << endl;
        cout << "                         | 5 - SAIR                     |" << endl;
        cout << "                         |______________________________|" << endl;
        cin >> menu;


        switch(menu)
        {

        case 1:
        {
            int contagem;
            int movimentos = 0;
            int contbaixo;
            int contcima;
            int contdireita;
            int contesquerda;
            int pontos;
            string nome;

            system("cls");
            cout <<"selecione a dificuldade:" << endl;
            cout << "1 - facil" << endl << "2 - medio" << endl << "3 - dificil" << endl;
            int dificuldade;
            cin >> dificuldade;



            switch(dificuldade)
            {
            case 1:
                pontos=900;
                dificuldade=3;
                Inimigos.resize(dificuldade);
                cout << "digite o seu nome" << endl;
                cin >> nome;
                PlaySound(TEXT("trilha.wav"), NULL, SND_ASYNC);



                break;

            case 2:
                pontos = 600;
                PlaySound(TEXT("trilha.wav"), NULL, SND_ASYNC);

                dificuldade=5;
                Inimigos.resize(dificuldade);
                break;

            case 3:
                pontos = 400;
                PlaySound(TEXT("trilha.wav"), NULL, SND_ASYNC);

                dificuldade=7;
                Inimigos.resize(dificuldade);
                break;
            default:
                cout<<"Dificuldade invalida!"<<endl;
                return 1;
            }
            GeracaoInimigo(m,dificuldade,InimigoPosicoes);
            for(int i=0; i<dificuldade; i++)
            {
                Inimigos[i]= {InimigoPosicoes[i].first,InimigoPosicoes[i].second};
            }

            int InimigosVivos = Inimigos.size();

            system("cls");

            auto inicio = steady_clock::now();
            while(GameContinue)
            {
                ///Posiciona a escrita no iicio do console
                SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);

                ///Imprime o jogo: mapa e personagem.
                for(int i=0; i<10; i++)
                {
                    for(int j=0; j<20; j++)
                    {
                        bool isEnemy = false;

                        if(i==J[0].x && j==J[0].y)
                        {
                            cout<<char(36); //personagem
                        }
                        else if (i==XB&&j==YB)
                        {
                            cout<<char(022); //bomba
                        }
                        else
                        {
                            for(const auto& inimigo : Inimigos)
                            {
                                if(i==inimigo.xi&&j==inimigo.yi)
                                {
                                    cout<<enemy;
                                    isEnemy = true;
                                    break;
                                }
                            }
                            if(!isEnemy)
                            {
                                switch (m[i][j])
                                {
                                case 0:
                                    cout<<" ";
                                    break;       //caminho
                                case 1:
                                    cout<<char(219);
                                    break; //parede
                                case 2:
                                    cout<<char(176);
                                    break; //parede quebravel
                                    //default: cout<<"-"; //erro
                                }   //fim switch
                            }
                        }
                    }
                    cout<<"\n";
                } //fim for mapa

                ///executa os movimentos

                if (_kbhit())
                {
                    tecla = getch();
                    bool movimento_valido = false;
                    bool bomba_colocada = true;
                    switch(tecla)
                    {
                    case 72:
                    case 'w': ///cima
                        J[0].x--;
                        if(!colisao(m[J[0].x][J[0].y]))
                        {
                            J[0].x++;
                        }
                        else
                        {
                            do
                            {
                                int c = 1;
                                contcima+= c;
                                c++;
                                movimentos++;
                                movimento_valido = true;
                            }
                            while(false);
                        }
                        break;
                    case 80:
                    case 's': ///baixo
                        J[0].x++;
                        if(!colisao(m[J[0].x][J[0].y]))
                        {
                            J[0].x--;
                        }
                        else
                        {
                            do
                            {
                                int ba = 1;
                                contbaixo+=ba;
                                ba++;
                                movimentos++;
                                movimento_valido = true;
                            }
                            while(false);
                        }


                        break;
                    case 75:
                    case 'a': ///esquerda

                        J[0].y--;
                        if(!colisao(m[J[0].x][J[0].y]))

                        {
                            J[0].y++;

                        }
                        else
                        {
                            do
                            {
                                int es = 1;
                                contesquerda+=es;
                                es++;
                                movimentos++;
                                movimento_valido=true;
                            }
                            while(false);
                        }

                        break;
                    case 77:
                    case 'd': ///direita

                        J[0].y++;
                        if(!colisao(m[J[0].x][J[0].y]))
                        {

                            J[0].y--;

                        }
                        else
                        {
                            do
                            {
                                int di = 1;
                                contdireita+=di;
                                di++;

                                movimentos++;
                                movimento_valido=true;
                            }
                            while(false);
                        }

                        break;


                    case 78:

                    case 'e': ///bomba

                        if(XB==-3&&YB==-3)
                        {
                            XB=J[0].x;
                            YB=J[0].y;
                            m[XB][YB]=3;
                            do
                            {
                                int b = 1;

                                contagem+= b;
                                b++;
                                bomba_colocada = true;
                            }
                            while(false);
                            Explosoes.clear();
                            ///DEFINE A AREA DAS EXPLOSÕES
                            Explosoes.push_back({XB-1,YB}); ///CIMA
                            Explosoes.push_back({XB+1,YB}); ///BAIXO
                            Explosoes.push_back({XB,YB-1}); ///ESQUERDA
                            Explosoes.push_back({XB,YB+1}); ///DIREITA
                        }
                        break;

                    }
                    if(movimento_valido)
                    {
                        if(dificuldade==3)
                        {
                            pontos-=1;
                        }
                        else if(dificuldade==5)
                        {
                            pontos-=1;
                        }
                        else if(dificuldade==7)
                        {
                            pontos-=1;

                        }
                    }
                    if(bomba_colocada)
                    {
                        if(dificuldade==3)
                        {
                            pontos--;
                        }
                        else if(dificuldade==5)
                        {
                            pontos-=3;
                        }
                        else if(dificuldade==7)
                        {
                            pontos-=7;
                        }

                    }

                }
                if(JogadoresVivos==0)
                {
                    GameContinue = false;
                }

                if(XB!=-3&&YB!=-3)  ///BOMBA
                {
                    auto TempoBombaAgora = chrono::high_resolution_clock::now();
                    auto BombaPassou = duration_cast<milliseconds>(TempoBombaAgora-InicioBomba);
                    if(BombaPassou>=BombaTimer)
                    {
                        for (auto &player : J)
                        {
                            for (const auto &ExplosaoBomba : Explosoes)
                            {
                                if (player.x == ExplosaoBomba.xboom && player.y == ExplosaoBomba.yboom)
                                {
                                    JogadoresVivos--;
                                }
                            }
                        }
                        for(auto &inimigo:Inimigos)
                        {
                            for(const auto& ExplosaoBomba : Explosoes)
                            {
                                if(m[ExplosaoBomba.xboom][ExplosaoBomba.yboom]==2)
                                {
                                    m[ExplosaoBomba.xboom][ExplosaoBomba.yboom]=0;
                                }
                                if(inimigo.xi == ExplosaoBomba.xboom && inimigo.yi == ExplosaoBomba.yboom)
                                {
                                    inimigo.xi=-1;
                                    inimigo.yi=-1;
                                    InimigosVivos--;
                                    bool verificacao_inimigos = true;
                                    if(verificacao_inimigos)
                                    {
                                        if(dificuldade==3)
                                        {
                                            pontos+=2;

                                        }
                                        else if(dificuldade==5)
                                        {
                                            pontos+=3;
                                        }
                                        else if(dificuldade==7)
                                        {
                                            pontos+=5;
                                        }
                                    }
                                }
                            }
                        }
                        m[XB][YB]=0;
                        XB=-3;
                        YB=-3;
                        InicioBomba=TempoBombaAgora;
                    }

                }

                ///executa os movimentos dos inimigos

                auto TempoAgora = chrono::high_resolution_clock::now();         ///Tempo recebe o tempo do clock, agora;
                auto Passou = duration_cast<milliseconds>(TempoAgora-Inicio);   ///Não precisa desse durantion cast pois ele converte os valores para millisegundos, sendo que as variaveis ja sao em millisegundos o que importa mesmo esta entre os ()
                if(Passou>TempoInimigo)
                {
                    Inicio = TempoAgora; ///inico recebe o tempo atual
                    MovimentoInimigo(Inimigos,J[0],dificuldade,m);
                }

                for(auto &player:J)  ///VERIFICAÇÃO DE VITORIA DO JOGO
                {
                    for(auto &inimigo:Inimigos)
                    {
                        if(inimigo.xi==player.x&&inimigo.yi==player.y)
                        {
                            JogadoresVivos--;
                        }
                        if(InimigosVivos==0)
                        {
                            GameContinue = false;
                        }
                    }
                }

                auto final = steady_clock::now();
                auto tempo = final - inicio;
                cout << " _________________________________________________________________" << endl;
                cout << "                         PONTUACAO:" << pontos                   << endl;
                cout << " TEMPO: " << duration_cast<seconds>(tempo).count() <<            "     "<< endl;
                cout << " MOVIMENTOS: " << movimentos << "                                 " << endl;
                cout << "                                                                  " << endl;
                cout << " BOMBAS USADAS: " << contagem << "       ITENS PEGOS:             " << endl;
                cout << "__________________________________________________________________" << endl;

                if(InimigosVivos==0)
                {
                    cout<<"voce venceu!"<<endl;
                }
                if(JogadoresVivos==0)
                {
                    cout<<"voce perdeu!"<<endl;
                }

            } //fim do laco do jogo

            break;
        }
        case 2:
        {
            system ("cls");
            "Tutorial de Bomberman\n\n";
            cout << "Objetivo:\n";
            cout << "Seu objetivo principal e limpar cada mapa de todos os inimigos, utilizando suas bombas de forma inteligente.\n\n";
            cout << "Controles:\n";
            cout << "- Utilize as teclas:\n";
            cout << "  - W: Movimento para cima\n";
            cout << "  - A: Movimento para a esquerda\n";
            cout << "  - S: Movimento para baixo\n";
            cout << "  - D: Movimento para a direita\n";
            cout << "  - E: Colocar uma bomba\n\n";
            cout << "Como Jogar:\n";
            cout << "1. Explosoes: Quando uma bomba explode, ela causa danos em um raio ao seu redor. Tenha cuidado para nao ser pego na explosao!\n";
            cout << "2. Destrua Paredes: Algumas paredes podem ser destruidas pelas explosoes das bombas.\n";
            cout << "3. Voce pode encontrar itens especiais que aumentam o alcance de suas bombas ou concedem poderes adicionais.\n";
            cout << "4. Inimigos: Enfrente os inimigos pelo caminho, evitando suas investidas e utilizando suas bombas de forma estrategica para elimina-los.\n";
            cout << "5. Mapas: Avance atraves dos mapas, enfrentando inimigos cada vez mais desafiadores, ate chegar ao ultimo mapa e derrotar o chefao final.\n\n";


            system("pause");
            break;
        }

        case 3:
        {
            system("cls");

            cout << "PONTUACAO: " << endl;
            // Fácil
            cout << "FACIL" << endl;
            cout << "No modo facil o jogador inicia com 900 pontos \n"
                 << "A cada movimento retira-se 1 ponto da pontuacao total\n"
                 << "A cada bomba colocada retira-se 1 ponto da pontuacao total\n"
                 << "A cada inimigo abatido soma-se 3 pontos na pontuacao total\n\n";

            // Medio
            cout << "MEDIO" << endl;
            cout << "No modo medio o jogador inicia com 600 pontos \n"
                 << "A cada movimento retira-se 3 pontos da pontuacao total\n"
                 << "A cada bomba colocada retira-se 3 pontos da pontuacao total\n"
                 << "A cada inimigo abatido soma-se 5 pontos na pontuacao total\n\n";

            // Dificil
            cout << "DIFICIL" << endl;
            cout << "No modo dificil o jogador inicia com 200 pontos \n"
                 << "A cada movimento retira-se 7 pontos da pontuacao total\n"
                 << "A cada bomba colocada retira-se 7 pontos da pontuacao total\n"
                 << "A cada inimigo abatido soma-se 10 pontos na pontuacao total\n";
            system("pause");

            break;
        }
        case 4:
        {
            system("cls");


            cout << "\nRANKING:\n";


        };
        system("pause");

        case 5:
        {
            break;
        }

        }
    }
    while(menu!=5);

    return 0;
} //fim main
